\chapter{Discussione}
\label{chap:discussion}

\section{Commenti al Codice}
\label{sec:comments}
\begin{enumerate}
\item Partendo dal principio, analizziamo la riga \emph{get\_ipython} e \emph{ipy.run\_line\_magic("matplotlib,"inline")}: queste righe partono dalla necessità di fare solo un piccolo debug non necessario al reale algoritmo, ma necessario quando l'input è ancora un'immagine singola per mostrare all'utente come visto in \ref{sec:func} le operazioni di instance segmentation su un'immagine. Senza queste righe non ci sarebbe il grafico a provare questo tipo di lavoro e quindi non si sarebbe sviluppato con certezza la parte dell'algoritmo che serve realmente e cioè quella dove l'input è un video.\\
\item L'istruzione \emph{parse.parseargs()} serve chiaramente ad ottenere i parametri di ingresso che sono stati specificati dall'utente per poi controllare se c'è in input un video/immagine oppure c'è una richiesta di fine tuning.
\item Dopo il controllo che sia effettivamente una richiesta di fine tuning, ci sono le istruzioni già descritte: \emph{f\_tune = FineTuning() e f\_tune.start()} per iniziare il training della rete.
\item Dopo il controllo che invece sia un video/immagine, viene creata una variabile \emph{config=CleverConfig()} che viene utilizzata per creare il model e dopo vengono caricati i pesi. Infine, vengono creati un array con la lista delle classi e i colori:
\emph{classes = ["BG","player","ball"] e COLORS = ["green","red","blue"]}
\item Dopo ciò, viene salvata una path che indirizza verso la cartella del dataset DATASET\_PATH e si controlla con \emph{os.path.exists(DATASET\_PATH+args.input)} se questo file specificato in args.input esiste in quella path, in caso contrario il programma termina.
\item In caso positivo, si legge il file video con l'istruzione \emph{vread} e se ne leggono i metadati interessanti quali \textbf{fps,height,width} per poi creare un nome che è quello del video originale concatenato al timestamp come nome del video codificato.
\item Si crea quindi un oggetto \textbf{FFMpegWriter} e si munisce dei parametri ottenuti con i metadati uniti al codec scelto \textbf{hecv\_nvenc}, e al parametro di qualità costante con la qualità scelta. Da notare che come enunciato in \textsuperscript{\textbf{\ref{chap:debug}}} il flag verbosity è attivo.
\item In seguito, si entra nel ciclo madre di tutto l'algoritmo dove si scorrono i frames contenuti nell'oggetto \emph{reader} e se ne controlla se risultano \textbf{None}, in caso contrario si effettua prima l'object detection con il metodo \emph{detect}, e infine la quantizzazione.
\item Infine, si rilasciano le risorse dell'oggetto  \textbf{FFMpegWriter} con l'istruzione \emph{close()}.
\item Per concludere, rileggiamo il file originale e lo confrontiamo con varie metriche di qualità paragonandolo a quello codificato con \textbf{FFMpegWriter} e quantizzato per Region of Interest. Le metriche di qualità usate sono: \textbf{SSIM,BRISQUE,LPIPS}.
\end{enumerate}
\section{Debug}
\label{sec:debug}
Il codec hevc\_nvenc, adottato e spiegato a inizio documentazione, non è stato adottato casualmente per disponibilità di questo encoder nella lista, ma per essere adottato è stato seguito un procedimento più ostico che merita una descrizione accurata. 
Innanzitutto la versione di \textbf{FFMPEG} adottata non è stata compilata con i flag adatti per una scelta di un encoder H.265, per cui abbiamo dovuto reinstallare la stessa in maniera differente: ciò verrà spiegato in seguito. Come prima cosa, nell'uso di questa libreria grazie all'istruzione \textbf{FFmpegWriter} abbiamo potuto constatare che vi era un errore bloccante che non veniva descritto con verbosità tale da capirne l'origine. A video l'errore si limitava a essere descritto come \emph{broken pipe} non appena veniva iniziata la scrittura del primo frame del video di cui si iniziava la codifica, anche se la libreria usata era "libx264". Per causa di ciò, dopo accurate ricerche, si è dovuto impostare un paramentro aggiuntivo nell'istruzione di creazione dell'oggetto \textbf{FFmpegWriter} scritto come \emph{verbosity=1}. A questo punto, grazie ad un log dell'errore con verbosità maggiore come segue: \emph{Unrecognized option 'height’} e \emph{Unknown decoder 'libx265'} si è potuto constatare che l'errore dipendeva da questi parametri e abbiamo così preso alcuni provvedimenti. Il parametro height è stato tolto, mentre per l'encoder scelto abbiamo testato se effettivamente questo non fosse disponibile con l'istruzione: \emph{ffmpeg -codecs } | \emph{grep 26} ed è risultato che il codec \textbf{hevc} esiste ma è utilizzabile solo per la decodifica.\\
Cercando nel canale loopbio abbiamo potuto confermare che si può attivare la codifica H.265 utilizzando un pacchetto del canale stesso, ma ciò è possibile disinstallando\\ \textbf{FFMPEG} e \textbf{x264,x265} con l'istruzione:
\emph{conda uninstall x264 x265 ffmpeg —force} e reinstallandoli dal canale loopbio con l'istruzione: \emph{conda install ffmpeg x264 x265 -c loopbio --force-reinstall}\\
Un problema aggiuntivo si è verificato in quanto la versione di x264 non è alla versione richiesta di \textbf{FFMPEG}, e l'errore se utilizzata l'istruzione \emph{ffmpeg -codecs } risulta: \emph{error while loading shared libraries: libx264.so.138: cannot open shared object file: No such file or directory.}\\
Di conseguenza, abbiamo dovuto cercare il package che fornisce la versione di x264 che \textbf{FFMPEG} desidera, con l'istruzione: \emph{ls -la ~/miniconda3/envs/tf\_cpu/lib/libx2*} e ciò è sfociato con l'istruzione: \emph{conda install -c lightsource2 x264}\\
Adesso ffmpeg -codecs | grep 26 riporta:\\
 DEV.L. hevc H.265 / HEVC (High Efficiency Video Coding)  (encoders: nvenc\_hevc hevc\_nvenc )
\\La Lettera "E" nelle iniziali "DEVL" significa che è possibile a questo punto effettuare una codifica, oltre alla decodifica che era già possibile inizialmente.\\
 A questo punto, è bastato sostituire il parametro \textbf{-vcodec} da \textbf{libx265} a \textbf{hevc\_nvenc} per far partire la codifica con l'encoder ottimale scelto.
